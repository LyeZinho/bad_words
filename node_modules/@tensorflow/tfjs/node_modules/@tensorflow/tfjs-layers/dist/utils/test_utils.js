"use strict";
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Testing utilities.
 */
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var jasmine_util_1 = require("@tensorflow/tfjs-core/dist/jasmine_util");
var state_1 = require("../backend/state");
var errors_1 = require("../errors");
/**
 * Expect values are close between an Tensor or number array.
 * @param actual
 * @param expected
 */
function expectTensorsClose(actual, expected, epsilon) {
    if (actual == null) {
        throw new errors_1.ValueError('First argument to expectTensorsClose() is not defined.');
    }
    if (expected == null) {
        throw new errors_1.ValueError('Second argument to expectTensorsClose() is not defined.');
    }
    tfjs_core_1.test_util.expectArraysClose(actual, expected, epsilon);
}
exports.expectTensorsClose = expectTensorsClose;
/**
 * Expect values in array are within a specified range, boundaries inclusive.
 * @param actual
 * @param expected
 */
function expectTensorsValuesInRange(actual, low, high) {
    if (actual == null) {
        throw new errors_1.ValueError('First argument to expectTensorsClose() is not defined.');
    }
    tfjs_core_1.test_util.expectValuesInRange(actual.dataSync(), low, high);
}
exports.expectTensorsValuesInRange = expectTensorsValuesInRange;
/**
 * Describe tests to be run on CPU and GPU.
 * @param testName
 * @param tests
 */
function describeMathCPUAndGPU(testName, tests) {
    jasmine_util_1.describeWithFlags(testName, tfjs_core_1.test_util.ALL_ENVS, function () {
        beforeEach(function () {
            state_1.disposeScalarCache();
        });
        tests();
    });
}
exports.describeMathCPUAndGPU = describeMathCPUAndGPU;
/**
 * Describe tests to be run on CPU only.
 * @param testName
 * @param tests
 */
function describeMathCPU(testName, tests) {
    jasmine_util_1.describeWithFlags(testName, tfjs_core_1.test_util.CPU_ENVS, function () {
        beforeEach(function () {
            state_1.disposeScalarCache();
        });
        tests();
    });
}
exports.describeMathCPU = describeMathCPU;
/**
 * Describe tests to be run on GPU only.
 * @param testName
 * @param tests
 */
function describeMathGPU(testName, tests) {
    jasmine_util_1.describeWithFlags(testName, tfjs_core_1.test_util.WEBGL_ENVS, function () {
        beforeEach(function () {
            state_1.disposeScalarCache();
        });
        tests();
    });
}
exports.describeMathGPU = describeMathGPU;
/**
 * Check that a function only generates the expected number of new Tensors.
 *
 * The test  function is called twice, once to prime any regular constants and
 * once to ensure that additional copies aren't created/tensors aren't leaked.
 *
 * @param testFunc A fully curried (zero arg) version of the function to test.
 * @param numNewTensors The expected number of new Tensors that should exist.
 */
function expectNoLeakedTensors(
// tslint:disable-next-line:no-any
testFunc, numNewTensors) {
    testFunc();
    var numTensorsBefore = tfjs_core_1.memory().numTensors;
    testFunc();
    var numTensorsAfter = tfjs_core_1.memory().numTensors;
    var actualNewTensors = numTensorsAfter - numTensorsBefore;
    if (actualNewTensors !== numNewTensors) {
        throw new errors_1.ValueError("Created an unexpected number of new " +
            ("Tensors.  Expected: " + numNewTensors + ", created : " + actualNewTensors + ". ") +
            "Please investigate the discrepency and/or use tidy.");
    }
}
exports.expectNoLeakedTensors = expectNoLeakedTensors;
//# sourceMappingURL=test_utils.js.map